import openflow::clock::Clock
import openflow::co2::Co2
import openflow::config::Config
import openflow::hue::(Hue, Sensors)
import openflow::itho::(Itho, Status)
import openflow::logger::Logger
import openflow::metrics::(Metric, Metrics)
import openflow::net::(online?)
import openflow::room::(Room, State)
import std::process::(sleep)
import std::time::(DateTime, Duration, Instant)

# The amount of time (in seconds) to wait after enabling manual mode, in order
# to give the exhausts/servos time to close.
let MANUAL_WAIT_TIME = 60

# The maximum value an exhaust setting can be set to to control how much it's
# opened.
let EXHAUST_MAX = 5000.0

# The flow rate (in m3/hour) to add to every room to compensate for higher CO2
# levels.
let CO2_ADD_FLOW = 10

# The amount of ppm for a single CO2 flow increment.
#
# For every such increment the CO2 levels are above the threshold, ventilation
# speed is increased.
let CO2_FLOW_INCREMENT = 100

# A type responsible with controlling the ventilation system, monitoring
# sensors, etc.
class pub Controller {
  # The rooms to monitor along with their state and configuration settings.
  #
  # This field must come first so it's dropped before the `Config` field, as
  # each `Room` contains a reference to a `openflow::config::Room`.
  #
  # This field is public so we can access the room states in our tests.
  let pub @rooms: Array[Room]

  # The last known speed of the exhaust fan.
  #
  # The Itho API refreshes data periodically, and this may result in a new
  # status update still containing the old exhaust speed. By tracking this value
  # manually we prevent unnecessary API calls and exhaust speed adjustments.
  let @exhaust_speed: Int

  # The last time the exhaust speed was updated.
  let @last_exhaust_update: Instant

  let @itho: Itho
  let @hue: Hue
  let @logger: Logger
  let @config: Config
  let @clock: Clock
  let @co2: Co2
  let @metrics: Metrics

  fn pub static new(
    config: Config,
    itho: Itho,
    hue: Hue,
    clock: Clock,
    logger: Logger,
  ) -> Controller {
    Controller {
      @itho = itho,
      @hue = hue,
      @rooms = config.rooms.iter.map fn (cfg) { Room.new(cfg) }.to_array,
      @logger = logger,
      @clock = clock,
      @exhaust_speed = 0,
      @last_exhaust_update = Instant.new,
      @co2 = Co2.new(config.co2.sample_time.clone),
      @metrics = try! Metrics.new(config.metrics.ip.clone, config.metrics.port),
      @config = config,
    }
  }

  # Prepares the DemandFlow system for manual control.
  fn pub mut prepare {
    let close_manually = enable_manual_control

    reset_exhaust_speed

    if close_manually { close_exhausts }
  }

  # Runs a single iteration of the work loop.
  fn pub mut iteration {
    let sensors = try! @hue.sensors
    let status = try! @itho.status

    update_co2(status)
    update_rooms(status, sensors)
    ventilate_default_room
    apply_changes
  }

  fn mut enable_manual_control -> Bool {
    if try! { @itho.get(@config.exhaust.manual_setting) } == 1 {
      @logger.info('Manual control is already enabled')
      return true
    }

    @logger.info('Enabling manual control')
    try! @itho.set(@config.exhaust.manual_setting, value: 1)

    @logger.info('Waiting for all exhausts to close')
    sleep(Duration.from_secs(MANUAL_WAIT_TIME))
    false
  }

  fn mut reset_exhaust_speed {
    let speed = flow_percentage(@config.exhaust.min_flow)

    @logger.info('Resetting the exhaust speed to its minimum')
    try! @itho.set(@config.exhaust.speed_setting, value: speed)
    sleep(@config.exhaust.close_time)
  }

  fn mut close_exhausts {
    # While enabling manual control closes the exhausts, it only does so if
    # manual control wasn't already enabled. By closing the exhausts here we
    # ensure we start off with a clean state (i.e. in the event of a crash).
    @logger.info('Closing all exhausts')

    @rooms.iter_mut.each fn (room) {
      @logger.info("Closing exhaust for {room.config.name}")
      try! @itho.set(room.config.exhaust, value: 0)
      sleep(@config.exhaust.close_time)
    }
  }

  fn mut check_schedule(room: mut Room, time: ref DateTime) -> Bool {
    let schedule = match room.config.schedule {
      case Some(val) -> val
      case _ -> return false
    }

    if schedule.active?(time) {
      if room.state.schedule?.false? {
        logger.info("Enabling schedule for {room.config.name}")
        room.update(State.Schedule)
      }

      return true
    }

    if room.state.schedule? {
      logger.info("Disabling schedule for {room.config.name}")
      room.close
    }

    false
  }

  fn mut check_humidity(status: ref Status, room: mut Room) -> Bool {
    let humidity = room
      .config
      .humidity
      .as_ref
      .then fn (name) { status.humidity.get(name) }
      .unwrap_or(0)

    if humidity > 0 {
      @metrics.send(Metric.with('humidity') fn (m) {
        m.tag('room', room.config.name)
        m.field('percentage', humidity)
      })
    }

    if humidity >= @config.humidity.high {
      match room.state {
        case Humid -> room.update_time
        case Open or MaybeHumid -> {
          if room.stale?(@config.humidity.high_time) {
            logger.info("The humidity in {room.config.name} is too high")
            room.update(State.Humid)
          }
        }
        case _ -> room.update(State.MaybeHumid)
      }
    } else if humidity > @config.humidity.low {
      match room.state {
        case Closed or Minimum -> {
          if room.stale?(@config.humidity.low_time) {
            logger.info("The humidity in {room.config.name} is increasing")
            room.update(State.Open)
          }
        }
        case MaybeHumid -> room.close
        case Open or Humid -> room.update_time
        case _ -> {}
      }
    } else if humidity <= @config.humidity.low {
      match room.state {
        case MaybeHumid -> room.close
        case Humid if room.stale?(@config.humidity.low_time) -> {
          logger.info("The humidity in {room.config.name} OK again")
          room.update(State.Open)
        }
        case _ -> {}
      }
    }

    match room.state {
      case Humid or MaybeHumid -> true
      case _ -> false
    }
  }

  fn mut check_motion(sensors: ref Sensors, room: mut Room, time: ref DateTime) {
    let conf = match room.config.motion {
      case Some(conf) -> conf
      case _ -> return
    }

    if sensors.motion[conf.id] {
      room.motion_events = room.motion_events.wrapping_add(1)

      @metrics.send(Metric.with('motion') fn (m) {
        m.tag('room', room.config.name)
        m.field('total', room.motion_events)
      })

      match room.state {
        case Closed or Minimum -> {
          logger.info("Motion detected in {room.config.name}")

          let new_state = if conf.minutes == 1 {
            State.Open
          } else {
            State.Motion(time.minute, 1)
          }

          room.update(new_state)
        }
        case Motion(min, count) if min != time.minute -> {
          let new_count = count + 1
          let new_state = if new_count == conf.minutes {
            logger.info("Enabling ventilation for {room.config.name}")
            State.Open
          } else {
            logger.info("More motion detected for {room.config.name}")
            State.Motion(time.minute, new_count)
          }

          room.update(new_state)
        }
        case Open -> room.update_time
        case Default -> room.update(State.Open)
        case _ -> {}
      }

      return
    }

    match room.state {
      case Open if room.stale?(room.config.ventilation_time) -> {
        # Pinging takes a few seconds depening on the number of IPs to ping, so
        # we only do this if the timer is about to expire.
        let reset = room.config.ping.iter.any? fn (ip) { online?(ip) }

        if reset {
          logger.info(
            "One or more hosts are online, resetting timer for \
            {room.config.name}"
          )
          room.update_time
        } else {
          logger.info("Disabling ventilation for {room.config.name}")
          room.close
        }
      }
      case Motion(_, _) if room.stale?(conf.time) -> {
        logger.info("Not enough motion detected in {room.config.name}")
        room.close
      }
      case _ -> {}
    }
  }

  fn update_exhaust_speed?(new_speed: Int) -> Bool {
    if new_speed > @exhaust_speed {
      true
    } else if new_speed < @exhaust_speed {
      @last_exhaust_update.elapsed >= @config.exhaust.reduce_wait_time
    } else {
      false
    }
  }

  fn mut update_co2(status: ref Status) {
    let old_co2 = @co2.value

    @co2.add(status.co2)

    if @co2.update and @co2.value != old_co2 {
      logger.info("CO2 estimate updated to {@co2.value} ppm")
    }

    @metrics.send(Metric.with('co2') fn (m) {
      m.field('ppm', status.co2)
      m.field('bucket', @co2.value)
    })
  }

  fn mut update_rooms(status: ref Status, sensors: ref Sensors) {
    let time = @clock.now

    @rooms.iter_mut.each fn (room) {
      # If the schedule is active, it takes priority over the remaining inputs.
      if check_schedule(room, time) { return }

      # If the room is humid we ignore any other sensor inputs.
      if check_humidity(status, room) { return }

      check_motion(sensors, room, time)
    }
  }

  fn mut ventilate_default_room {
    # No ventilation can result in stale/dirty air building up. As such, if we
    # don't detect the need for ventilating anywhere we'll just ventilate the
    # first room.
    let ventilate_first = @rooms.iter.all? fn (room) {
      match room.state {
        case Open or Humid or Schedule -> false
        case _ -> true
      }
    }

    let room = @rooms[0]

    if ventilate_first {
      match room.state {
        case Default -> room.update_time
        case _ -> {
          logger.info("Enabling default ventilation for {room.config.name}")
          room.update(State.Default)
        }
      }
    } else {
      match room.state {
        case Default -> {
          logger.info("Disabling ventilation for {room.config.name}")
          room.close
        }
        case _ -> {}
      }
    }
  }

  fn mut apply_changes {
    let humid = @rooms.iter.any? fn (room) {
      match room.state { case Humid -> true, case _ -> false }
    }

    let extra_flow = if @co2.value > @config.co2.target and humid.false? {
      # As CO2 levels rise, we gradually increase the air flow in rooms that are
      # ventilated. in an attempt to keep the CO2 levels stable.
      #
      # If one or more rooms are humid we don't do this, as in such a case we're
      # already ventilating one or more rooms at a very high speed, and chances
      # are that CO2 increases originate from the same room anyway (i.e a person
      # taking a shower).
      @co2.value - @config.co2.target / CO2_FLOW_INCREMENT * CO2_ADD_FLOW
    } else {
      0
    }

    let room_flows = @rooms
      .iter
      .map fn (room) {
        match room.state {
          case Schedule or Open or Default -> {
            # When a room is humid the exhaust speed is increased to a high
            # speed. This can result in excessive noise in other rooms. To
            # prevent this from happening we reduce the flow rate of non humid
            # rooms, reducing how far the exhaust is opened, and thereby
            # hopefully keeping noise levels at a minimum.
            #
            # While this results in reduced ventilation in said rooms, in
            # practise this only is the case for 30-45 minutes, so it shouldn't
            # pose any problems.
            extra_flow
              + if humid { room.config.flow / 2 } else { room.config.flow }
          }
          case Motion(_, _) if room.config.minimum_flow > 0 -> {
            room.config.minimum_flow
          }
          case Humid -> @config.humidity.flow
          case _ -> room.config.minimum_flow
        }
      }
      .to_array

    let mut total_flow = room_flows.iter.reduce(0) fn (sum, val) { sum + val }

    if total_flow > @config.exhaust.max_flow {
      total_flow = @config.exhaust.max_flow
    } else if total_flow < @config.exhaust.min_flow {
      total_flow = @config.exhaust.min_flow
    }

    @rooms.iter_mut.each_with_index fn (index, room) {
      let flow = room_flows[index]
      let exhaust = if flow >= total_flow {
        EXHAUST_MAX.to_int
      } else {
        (flow.to_float / total_flow.to_float * EXHAUST_MAX).ceil.to_int
      }

      @metrics.send(Metric.with('air_flow') fn (m) {
        m.tag('room', room.config.name)
        m.field('rate', flow)
        m.field('setting', exhaust)
      })

      if exhaust == room.exhaust { return }

      logger.info(
        "Changing exhaust setting for {room.config.name} from \
        {room.exhaust} to {exhaust} ({flow} m3/h)"
      )
      room.exhaust = exhaust

      try! @itho.set(setting: room.config.exhaust, value: exhaust)
      sleep(@config.exhaust.close_time)
    }

    let new_speed = flow_percentage(total_flow)

    if update_exhaust_speed?(new_speed) {
      logger.info(
        "Changing exhaust speed from {@exhaust_speed}% to \
        {new_speed}% ({total_flow} m3/h)"
      )
      try! @itho.set(setting: @config.exhaust.speed_setting, value: new_speed)
      sleep(@config.exhaust.close_time)
      @exhaust_speed = new_speed
      @last_exhaust_update = Instant.new
    }

    @metrics.send(Metric.with('exhaust_speed') fn (m) {
      m.field('percentage', new_speed)
    })
  }

  fn flow_percentage(flow: Int) -> Int {
    (flow.to_float / @config.exhaust.max_flow.to_float * 100.0).ceil.to_int
  }
}
