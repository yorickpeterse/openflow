import openflow::clock::Clock
import openflow::co2::Co2
import openflow::config::Config
import openflow::hue::(Hue, Sensors)
import openflow::itho::(Itho, RemoteStatus, Status)
import openflow::logger::Logger
import openflow::metrics::(Metric, Metrics)
import openflow::net::(online?)
import openflow::room::(Room, State as RoomState)
import std::cmp::(min, max)
import std::process::(sleep)
import std::string::ToString
import std::time::(DateTime, Duration, Instant)

# The state of an RF remote.
class pub Remote {
  # The current status of the remote.
  let pub @status: RemoteStatus

  # The timestamp of when the last command was received.
  let pub @timestamp: Int

  # The time after which the remote should be reset to its initial state.
  let pub @deadline: Instant

  fn pub static new -> Remote {
    Remote {
      @status = RemoteStatus.Low,
      @timestamp = 0,
      @deadline = Instant.new,
    }
  }

  fn active? -> Bool {
    match @status { case Low -> false, case _ -> true }
  }
}

# The internal state of a Controller.
#
# This type is used for a few states that can't be active at the same time. For
# example, we don't allow sampling of CO2 levels while there are humid rooms.
class enum State {
  # The default state of the controller.
  case Default

  # One or more rooms are humid.
  case Humid

  # We're sampling the CO2 levels of a room.
  case Co2

  fn humid? -> Bool {
    match self { case Humid -> true, case _ -> false }
  }

  fn co2? -> Bool {
    match self { case Co2 -> true, case _ -> false }
  }
}

impl ToString for State {
  fn pub to_string -> String {
    match self {
      case Default -> 'Default'
      case Humid -> 'Humid'
      case Co2 -> 'Co2'
    }
  }
}

# A type responsible with controlling the ventilation system, monitoring
# sensors, etc.
class pub Controller {
  let @state: State

  # The last known speed of the exhaust fan.
  #
  # The Itho API refreshes data periodically, and this may result in a new
  # status update still containing the old exhaust speed. By tracking this value
  # manually we prevent unnecessary API calls and exhaust speed adjustments.
  let @exhaust_speed: Int

  # The last time the exhaust speed was updated.
  let @last_exhaust_update: Instant

  # The last time we finished sampling rooms for their CO2 levels.
  let @last_co2_update: Instant

  # The last time we logged CO2 metrics.
  let @last_co2_metrics: Instant

  # The rooms to schedule for sampling of CO2 levels.
  let @co2_scheduled_rooms: Array[mut Room]

  # The rooms to monitor along with their state and configuration settings.
  #
  # This field must come before the `@config` field, as each `Room` has a
  # reference to data in the `Config` object. Placing it before the mentioned
  # field ensures these references are dropped before the values they point to.
  #
  # This field is public so we can access the room states in our tests.
  let pub @rooms: Map[String, Room]

  # The API client for interacting with the Itho device.
  let @itho: Itho

  # The API client for interacting with the Philips Hue bridge.
  let @hue: Hue

  # The logger to use for informational messages, warnings, etc.
  let @logger: Logger

  # A clock used for obtaining the current system time.
  let @clock: Clock

  # The metrics data to use for recording data such as the CO2 levels over time.
  let @metrics: Metrics

  # The state of an attached RF remote.
  let @remote: Remote

  # The global configuration settings
  let @config: Config

  fn pub static new(
    config: Config,
    itho: Itho,
    hue: Hue,
    clock: Clock,
    logger: Logger,
  ) -> Controller {
    Controller {
      @state = State.Default,
      @itho = itho,
      @hue = hue,
      @rooms = config.rooms.iter.reduce(Map.new) fn (map, entry) {
        map[entry.key] = Room.new(entry.value)
        map
      },
      @logger = logger,
      @clock = clock,
      @exhaust_speed = 0,
      @last_exhaust_update = Instant.new,
      @last_co2_update = Instant.new,
      @last_co2_metrics = Instant.new,
      @co2_scheduled_rooms = [],
      @metrics = try! Metrics.new(config.metrics.ip.clone, config.metrics.port),
      @remote = Remote.new,
      @config = config,
    }
  }

  # Prepares the DemandFlow system for manual control.
  fn pub mut prepare {
    let close_manually = enable_manual_control

    reset_exhaust_speed

    if close_manually { close_exhausts }

    schedule_initial_co2_sampling
  }

  # Runs a single iteration of the work loop.
  fn pub mut iteration {
    let sensors = try! @hue.sensors
    let status = try! @itho.status

    update_co2(status)
    send_co2_metrics(status)
    check_remotes
    update_rooms(status, sensors)
    ventilate_default_room
    apply_changes
  }

  fn mut enable_manual_control -> Bool {
    if try! { @itho.get(@config.exhaust.manual_setting) } == 1 {
      @logger.info('Manual control is already enabled')
      return true
    }

    @logger.info('Enabling manual control')
    try! @itho.set(@config.exhaust.manual_setting, value: 1)

    let wait =
      Duration.from_nanos(@rooms.length * @config.exhaust.close_time.to_nanos)

    @logger.info('Waiting for all exhausts to close')
    sleep(wait)
    false
  }

  fn mut reset_exhaust_speed {
    let speed = flow_percentage(@config.exhaust.min_flow)

    @logger.info('Resetting the exhaust speed to its minimum')
    try! @itho.set(@config.exhaust.speed_setting, value: speed)
    sleep(@config.exhaust.close_time)
  }

  fn mut close_exhausts {
    # While enabling manual control closes the exhausts, it only does so if
    # manual control wasn't already enabled. By closing the exhausts here we
    # ensure we start off with a clean state (i.e. in the event of a crash).
    @logger.info('Closing all exhausts')

    @rooms.values.each fn (room) {
      info(room, 'Closing exhaust')
      try! @itho.set(room.config.exhaust, value: 0)
      sleep(@config.exhaust.close_time)
    }
  }

  fn mut check_schedule(room: mut Room, time: ref DateTime) -> Bool {
    if room.active_schedule?(time) {
      match room.state {
        case Schedule
          or ScheduleCo2 or Co2(_) or Button(_) or Humid or Open -> {}
        case _ -> {
          info(room, 'Enabling schedule')
          room.update(RoomState.Schedule)
        }
      }

      return true
    }

    if room.state.schedule? {
      info(room, 'Disabling schedule')
      room.update(RoomState.Closed)
    }

    false
  }

  fn mut check_humidity(status: ref Status, room: mut Room) -> Bool {
    let humidity = room
      .config
      .humidity
      .as_ref
      .then fn (name) { status.humidity.get(name) }
      .unwrap_or(0)

    if humidity > 0 {
      @metrics.send(Metric.with('humidity') fn (m) {
        m.tag('room', room.config.name)
        m.field('percentage', humidity)
      })
    }

    if humidity >= @config.humidity.high {
      match room.state {
        case Humid -> room.update_time
        case Open or MaybeHumid -> {
          if room.stale?(@config.humidity.high_time) {
            info(room, 'The humidity is too high')
            room.update(RoomState.Humid)
            room.humid_at = Instant.new
          }
        }
        case _ -> room.update(RoomState.MaybeHumid)
      }
    } else if humidity > @config.humidity.low {
      match room.state {
        case Humid -> room.update_time
        case _ -> {}
      }
    } else if humidity <= @config.humidity.low {
      match room.state {
        case MaybeHumid -> room.update(RoomState.Closed)
        case Humid -> {
          # This ensures we ventilate for at least X minutes, then for an
          # additional Y minutes after going below the low threshold. This
          # approach is taken based on an observation of my own bathroom: when
          # starting a shower the humidity increases, then drops when the
          # ventilation is increased, after which it gradually climbs back up.
          # This drop and the climb back up to around 70-75% humidity takes
          # 15-20 minutes.
          #
          # The minimum time requirement ensures we don't stop ventilation
          # during that gap, while the low time ensures we don't keep
          # ventilating too long after reaching the low threshold, but also
          # don't stop right away as that may lead to humidity increasing again.
          if room.humid_at.elapsed >= @config.humidity.min_time
            and room.stale?(@config.humidity.low_time)
          {
            info(room, 'The humidity is OK again')
            room.update(RoomState.Open)
          }
        }
        case _ -> {}
      }
    }

    match room.state {
      case Humid or MaybeHumid -> true
      case _ -> false
    }
  }

  fn mut check_motion(
    sensors: ref Sensors,
    room: mut Room,
    time: ref DateTime
  ) -> Bool {
    if @state.co2? { return false }

    let conf = match room.config.motion {
      case Some(conf) -> conf
      case _ -> return false
    }

    if sensors.motion[conf.id] {
      room.motion_events = room.motion_events.wrapping_add(1)

      @metrics.send(Metric.with('motion') fn (m) {
        m.tag('room', room.config.name)
        m.field('total', room.motion_events)
      })

      match room.state {
        case Closed or Minimum -> {
          info(room, 'Motion detected')

          let new_state = if conf.minutes == 1 {
            RoomState.Open
          } else {
            RoomState.Motion(time.minute, 1)
          }

          room.update(new_state)
        }
        case Motion(min, count)
          if min != time.minute and room.stale?(conf.interval) ->
        {
          let new_count = count + 1
          let new_state = if new_count == conf.minutes {
            info(room, 'Enabling ventilation')
            RoomState.Open
          } else {
            info(room, 'More motion detected')
            RoomState.Motion(time.minute, new_count)
          }

          room.update(new_state)
        }
        case Default -> {
          info(room, 'Enabling regular ventilation')
          room.update(RoomState.Open)
        }
        case Open -> room.update_time
        case _ -> {}
      }

      return true
    }

    match room.state {
      case Open if room.stale?(room.config.ventilation_time) -> {
        # Pinging takes a few seconds depening on the number of IPs to ping, so
        # we only do this if the timer is about to expire.
        let reset = room.config.ping.iter.any? fn (ip) { online?(ip) }

        if reset {
          info(room, 'One or more hosts are online, resetting timer')
          room.update_time
        } else {
          info(room, 'Disabling ventilation')
          room.update(RoomState.Closed)
        }
      }
      case Motion(_, _) if room.stale?(conf.time) -> {
        info(room, 'Not enough motion detected')
        room.update(RoomState.Closed)
      }
      case _ -> {}
    }

    false
  }

  fn mut check_co2(room: mut Room) {
    match room.state {
      case Motion(_, _) or Closed -> if room.co2.value >= @config.co2.target {
        room.update(RoomState.Open)
      }
      case _ -> {}
    }
  }

  fn mut schedule_initial_co2_sampling {
    @rooms.iter_mut.select fn (e) { e.value.config.co2 }.each fn (entry) {
      let room = entry.value

      info(room, 'Scheduling initial CO2 sampling')
      room.update(RoomState.ScheduleCo2)
      @co2_scheduled_rooms.push(room)
    }
  }

  fn mut update_co2(status: ref Status) {
    # We postpone sampling in these cases as doing so could mess up ventilation
    # (e.g. by reducing the speed of the bathroom or kitchen extractor fan).
    if @remote.active? or @state.humid? { return }

    let sampling = @rooms.iter_mut.any? fn (entry) {
      let room = entry.value

      match room.state {
        case Co2(old_state) -> {
          let elapsed = room.last_update.elapsed
          let total_time =
            @config.co2.sample_wait_time + @config.co2.sample_time

          if elapsed > @config.co2.sample_wait_time { room.co2.add(status.co2) }

          if elapsed <= total_time {
            true
          } else {
            let old = room.co2.value

            room.update_co2
            room.update(old_state.clone)
            info(room, "CO2 changed from {old} ppm to {room.co2.value} ppm")

            # We update the time here so we don't start to immediately sample
            # again after sampling the last room.
            @last_co2_update = Instant.new
            false
          }
        }
        case _ -> false
      }
    }

    if sampling { return }

    loop {
      let room = match @co2_scheduled_rooms.pop {
        case Some(room) -> room
        case _ -> break
      }

      info(room, 'Sampling CO2')
      @state = State.Co2

      let old_state = match room.state {
        case ScheduleCo2 -> RoomState.Closed
        case state -> state.clone
      }

      # For rooms using motion sensors this effectively resets the motion
      # timeout. In practise this shouldn't pose much of a problem though,
      # because in the worst case we just ventilate a room for a little longer
      # than we're supposed to.
      room.update(RoomState.Co2(old_state))
      return
    }

    if @state.co2? {
      logger.info('Finished sampling all rooms, resetting the controller state')
      @state = State.Default
    }

    if sample_co2?.false? { return }

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      if room.sample_co2?(@config.co2) {
        info(room, 'Scheduling CO2 sampling')
        @co2_scheduled_rooms.push(room)
      }
    }
  }

  fn sample_co2? -> Bool {
    let last_sample = @last_co2_update.elapsed

    if last_sample >= @config.co2.sample_interval { return true }
    if last_sample < @config.co2.half_sample_interval { return false }

    let open = @rooms
      .values
      .select fn (room) {
        match room.state {
          case Open or Schedule or Default or Button(_) -> true
          case _ -> false
        }
      }
      .count

    # If only one or two rooms are ventilated we can sample more often, as in
    # such a case sampling takes very little time.
    open == 1 or open == 2
  }

  fn mut send_co2_metrics(status: ref Status) {
    if @last_co2_metrics.elapsed <= @config.co2.metrics_interval { return }

    @metrics.send(Metric.with('co2') fn (m) { m.field('ppm', status.co2) })

    @rooms
      .values
      .select fn (r) { r.config.co2 and r.co2.value > 0 }
      .each fn (room) {
        @metrics.send(Metric.with('co2_room') fn (m) {
          m.tag('room', room.config.name)
          m.field('ppm', room.co2.value)
        })
      }

    @last_co2_metrics = Instant.new
  }

  fn mut check_remotes {
    let conf = match @config.remote { case Some(val) -> val case _ -> return }
    let remotes = try! @itho.remotes
    let remote =
      match remotes.remove(conf.id) { case Some(val) -> val case _ -> return }

    # When starting up we ignore the current button state. This way if you
    # restart say six hours after pressing the Cook30 button, we don't start
    # ventilating according to that button again.
    if @remote.timestamp == 0 {
      @remote.timestamp = remote.timestamp
      return
    }

    if remote.timestamp == @remote.timestamp {
      let reset = match @remote.status {
        case Low -> false
        case _ -> @remote.deadline.remaining.to_nanos <= 0
      }

      if reset {
        logger.info("The {@remote.status} timer expired")
        @rooms.iter_mut.each fn (kv) { kv.value.reset_button }
        @remote.status = RemoteStatus.Low
      }

      return
    }

    @remote.status = remote.status.clone
    @remote.timestamp = remote.timestamp

    match @remote.status {
      case Low -> {
        logger.info("Resetting the remote to its default state")
        @rooms.iter_mut.each fn (entry) { entry.value.reset_button }
        return
      }
      case state -> match conf.buttons.get(state.name) {
        case Some(button) -> {
          @rooms.iter_mut.each fn (entry) { entry.value.reset_button }
          logger.info("Ventilating rooms for the {@remote.status} button")
          @remote.deadline = button.time.to_instant
          button.rooms.iter.each fn (name) {
            let room = @rooms[name]

            room.update(RoomState.Button(room.state.clone))
          }

          stop_co2_sampling
        }
        case _ -> {}
      }
    }
  }

  fn mut update_rooms(status: ref Status, sensors: ref Sensors) {
    let time = @clock.now

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      if check_schedule(room, time) { return }
      if check_humidity(status, room) { return }
      if check_motion(sensors, room, time) { return }

      check_co2(room)
    }

    if @rooms.values.any?(fn (r) { r.state.humid? }).false? {
      if @state.humid? {
        logger.info('No humid rooms left, resetting the controller state')
        @state = State.Default
      }

      return
    } else if @state.humid? {
      return
    }

    # We don't allow sampling while there are humid rooms, as sampling could
    # prevent ventilating such rooms. Even if we did allow it, it would distort
    # the statistics such that sampling is useless.
    stop_co2_sampling

    logger.info('Setting the controller state to Humid')
    @state = State.Humid
  }

  fn mut stop_co2_sampling {
    if @state.co2?.false? { return }

    logger.info('Forcefully stopping CO2 sampling')

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      match room.state {
        case Co2(old) -> room.update(old.clone)
        case ScheduleCo2 -> room.update(RoomState.Closed)
        case _ -> {}
      }
    }

    @co2_scheduled_rooms.clear
    @state = State.Default
    @last_co2_update = Instant.new
  }

  fn mut ventilate_default_room {
    # No ventilation can result in stale/dirty air building up. As such, if we
    # don't detect the need for ventilating anywhere we'll just ventilate the
    # first room.
    let ventilate = @rooms.iter.all? fn (entry) {
      match entry.value.state {
        case Open or Humid or Schedule or Button(_) or Co2(_) -> false
        case _ -> true
      }
    }

    @rooms.iter_mut.select fn (e) { e.value.config.default }.each fn (entry) {
      let room = entry.value

      if ventilate {
        match room.state {
          case Default -> room.update_time
          case _ -> {
            info(room, 'Enabling default ventilation')
            room.update(RoomState.Default)
          }
        }
      } else {
        match room.state {
          case Default -> {
            info(room, 'Disabling default ventilation')
            room.update(RoomState.Closed)
          }
          case _ -> {}
        }
      }
    }
  }

  fn mut air_flow_per_room -> Array[Int] {
    @rooms
      .iter_mut
      .map fn (entry) {
        let room = entry.value
        let base = match room.state {
          case Co2(_) -> {
            room.update_flow(@config.co2.target, @config.co2.high)
          }
          case Button(_) -> room.config.high_flow
          case Schedule or Open or Default -> match @state {
            # The only way we can get accurate per-room CO2 readings is to
            # temporarily disable ventilation of rooms we're not sampling.
            case Co2 -> 0

            # Humid rooms are typically ventilated at a high speed (e.g. 150
            # m3/h). Depending on how many other rooms are also ventilated, this
            # may result in a lot of noise, and potentially a lack of capacity
            # for the humid room. To handle this we temporarily reduce the
            # ventilation capacity of non-humid rooms.
            case Humid -> room.config.flow / 2
            case Default -> {
              room.update_flow(@config.co2.target, @config.co2.high)
            }
          }
          case Motion(_, _) if room.config.minimum_flow > 0 -> {
            room.minimum_flow(@state.co2?)
          }
          case Humid -> @config.humidity.flow
          case _ -> room.minimum_flow(@state.co2?)
        }

        (base.to_float * room.config.flow_correction).ceil.to_int
      }
      .to_array
  }

  fn mut apply_changes {
    let room_flows = air_flow_per_room
    let total_flow = max(
      @config.exhaust.min_flow,
      min(
        room_flows.iter.reduce(0, fn (sum, val) { sum + val }),
        @config.exhaust.max_flow
      )
    )

    let new_speed = flow_percentage(total_flow)

    # Speed reductions are applied first, while increases are applied last. This
    # ensures we don't produce excessive air noise while the exhaust valves are
    # adjusted.
    if new_speed < @exhaust_speed { update_exhaust_speed(new_speed) }

    @rooms.iter_mut.each_with_index fn (index, entry) {
      let room = entry.value
      let flow = room_flows[index]
      let exhaust = room.exhaust_setting(flow, total_flow)

      @metrics.send(Metric.with('air_flow') fn (m) {
        m.tag('room', room.config.name)
        m.field('rate', flow)
        m.field('setting', exhaust)
      })

      if exhaust == room.exhaust { return }

      info(
        room,
        "Changing exhaust from {room.exhaust} to {exhaust} ({flow} m3/h)"
      )
      room.exhaust = exhaust

      try! @itho.set(setting: room.config.exhaust, value: exhaust)
      sleep(@config.exhaust.close_time)
    }

    if new_speed > @exhaust_speed { update_exhaust_speed(new_speed) }

    @metrics.send(
      Metric.with('exhaust_speed') fn (m) { m.field('percentage', new_speed) }
    )
  }

  fn mut update_exhaust_speed(new_speed: Int) {
    if new_speed < @exhaust_speed
      and @last_exhaust_update.elapsed < @config.exhaust.reduce_wait_time
    {
      return
    }

    logger
      .info("Changing exhaust speed from {@exhaust_speed}% to {new_speed}%")

    try! @itho.set(setting: @config.exhaust.speed_setting, value: new_speed)
    sleep(@config.exhaust.close_time)
    @exhaust_speed = new_speed
    @last_exhaust_update = Instant.new
  }

  fn flow_percentage(flow: Int) -> Int {
    (flow.to_float / @config.exhaust.max_flow.to_float * 100.0).ceil.to_int
  }

  fn mut info(room: ref Room, message: String) {
    @logger.info("{room.config.name}: {message}")
  }
}
