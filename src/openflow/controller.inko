import openflow::clock::Clock
import openflow::co2::Co2
import openflow::config::Config
import openflow::hue::(Hue, Sensors)
import openflow::itho::(Itho, RemoteStatus, Status)
import openflow::logger::Logger
import openflow::metrics::(Metric, Metrics)
import openflow::net::(online?)
import openflow::room::(Room, State as RoomState)
import std::cmp::(min, max)
import std::process::(sleep)
import std::string::ToString
import std::time::(DateTime, Duration, Instant)

# The maximum value an exhaust setting can be set to to control how much it's
# opened.
let EXHAUST_MAX = 4000.0

# The state of an RF remote.
class pub Remote {
  # The current status of the remote.
  let pub @status: RemoteStatus

  # The timestamp of when the last command was received.
  let pub @timestamp: Int

  # The time after which the remote should be reset to its initial state.
  let pub @deadline: Instant

  fn pub static new -> Remote {
    Remote {
      @status = RemoteStatus.Low,
      @timestamp = 0,
      @deadline = Instant.new,
    }
  }

  fn active? -> Bool {
    match @status { case Low -> false, case _ -> true }
  }
}

# The internal state of a Controller.
#
# This type is used for a few states that can't be active at the same time. For
# example, we don't allow sampling of CO2 levels while there are humid rooms.
class enum State {
  # The default state of the controller.
  case Default

  # One or more rooms are humid.
  case Humid

  # We're sampling the CO2 levels of a room.
  case Co2

  fn humid? -> Bool {
    match self { case Humid -> true, case _ -> false }
  }

  fn co2? -> Bool {
    match self { case Co2 -> true, case _ -> false }
  }
}

impl ToString for State {
  fn pub to_string -> String {
    match self {
      case Default -> 'Default'
      case Humid -> 'Humid'
      case Co2 -> 'Co2'
    }
  }
}

# A type responsible with controlling the ventilation system, monitoring
# sensors, etc.
class pub Controller {
  let @state: State

  # The last known speed of the exhaust fan.
  #
  # The Itho API refreshes data periodically, and this may result in a new
  # status update still containing the old exhaust speed. By tracking this value
  # manually we prevent unnecessary API calls and exhaust speed adjustments.
  let @exhaust_speed: Int

  # The last time the exhaust speed was updated.
  let @last_exhaust_update: Instant

  # The last time we finished sampling rooms for their CO2 levels.
  let @last_co2_update: Instant

  # The last time we logged CO2 metrics.
  let @last_co2_metrics: Instant

  # The rooms to schedule for sampling of CO2 levels.
  let @co2_scheduled_rooms: Array[mut Room]

  # The rooms to monitor along with their state and configuration settings.
  #
  # This field must come before the `@config` field, as each `Room` has a
  # reference to data in the `Config` object. Placing it before the mentioned
  # field ensures these references are dropped before the values they point to.
  #
  # This field is public so we can access the room states in our tests.
  let pub @rooms: Map[String, Room]

  # The API client for interacting with the Itho device.
  let @itho: Itho

  # The API client for interacting with the Philips Hue bridge.
  let @hue: Hue

  # The logger to use for informational messages, warnings, etc.
  let @logger: Logger

  # A clock used for obtaining the current system time.
  let @clock: Clock

  # The metrics data to use for recording data such as the CO2 levels over time.
  let @metrics: Metrics

  # The state of an attached RF remote.
  let @remote: Remote

  # The global configuration settings
  let @config: Config

  fn pub static new(
    config: Config,
    itho: Itho,
    hue: Hue,
    clock: Clock,
    logger: Logger,
  ) -> Controller {
    Controller {
      @state = State.Default,
      @itho = itho,
      @hue = hue,
      @rooms = config.rooms.iter.reduce(Map.new) fn (map, entry) {
        map[entry.key] = Room.new(entry.value)
        map
      },
      @logger = logger,
      @clock = clock,
      @exhaust_speed = 0,
      @last_exhaust_update = Instant.new,
      @last_co2_update = Instant.new,
      @last_co2_metrics = Instant.new,
      @co2_scheduled_rooms = [],
      @metrics = try! Metrics.new(config.metrics.ip.clone, config.metrics.port),
      @remote = Remote.new,
      @config = config,
    }
  }

  # Prepares the DemandFlow system for manual control.
  fn pub mut prepare {
    let close_manually = enable_manual_control

    reset_exhaust_speed

    if close_manually { close_exhausts }

    schedule_initial_co2_sampling
  }

  # Runs a single iteration of the work loop.
  fn pub mut iteration {
    let sensors = try! @hue.sensors
    let status = try! @itho.status

    update_co2(status)
    send_co2_metrics(status)
    check_remotes
    update_rooms(status, sensors)
    ventilate_default_room
    apply_changes
  }

  fn mut enable_manual_control -> Bool {
    if try! { @itho.get(@config.exhaust.manual_setting) } == 1 {
      @logger.info('Manual control is already enabled')
      return true
    }

    @logger.info('Enabling manual control')
    try! @itho.set(@config.exhaust.manual_setting, value: 1)

    let wait =
      Duration.from_nanos(@rooms.length * @config.exhaust.close_time.to_nanos)

    @logger.info('Waiting for all exhausts to close')
    sleep(wait)
    false
  }

  fn mut reset_exhaust_speed {
    let speed = flow_percentage(@config.exhaust.min_flow)

    @logger.info('Resetting the exhaust speed to its minimum')
    try! @itho.set(@config.exhaust.speed_setting, value: speed)
    sleep(@config.exhaust.close_time)
  }

  fn mut close_exhausts {
    # While enabling manual control closes the exhausts, it only does so if
    # manual control wasn't already enabled. By closing the exhausts here we
    # ensure we start off with a clean state (i.e. in the event of a crash).
    @logger.info('Closing all exhausts')

    @rooms.values.each fn (room) {
      @logger.info("Closing exhaust for {room.config.name}")
      try! @itho.set(room.config.exhaust, value: 0)
      sleep(@config.exhaust.close_time)
    }
  }

  fn mut check_schedule(room: mut Room, time: ref DateTime) -> Bool {
    let schedule = match room.config.schedule {
      case Some(val) -> val
      case _ -> return false
    }

    if schedule.active?(time) {
      match room.state {
        case Closed or Minimum -> {
          logger.info("Enabling schedule for {room.config.name}")
          room.update(RoomState.Schedule)
        }
        case _ -> {}
      }

      return true
    }

    if room.state.schedule? {
      logger.info("Disabling schedule for {room.config.name}")
      room.update(RoomState.Closed)
    }

    false
  }

  fn mut check_humidity(status: ref Status, room: mut Room) -> Bool {
    let humidity = room
      .config
      .humidity
      .as_ref
      .then fn (name) { status.humidity.get(name) }
      .unwrap_or(0)

    if humidity > 0 {
      @metrics.send(Metric.with('humidity') fn (m) {
        m.tag('room', room.config.name)
        m.field('percentage', humidity)
      })
    }

    if humidity >= @config.humidity.high {
      match room.state {
        case Humid -> room.update_time
        case Open or MaybeHumid -> {
          if room.stale?(@config.humidity.high_time) {
            logger.info("The humidity in {room.config.name} is too high")
            room.update(RoomState.Humid)
            room.humid_at = Instant.new
          }
        }
        case _ -> room.update(RoomState.MaybeHumid)
      }
    } else if humidity > @config.humidity.low {
      match room.state {
        case Humid -> room.update_time
        case _ -> {}
      }
    } else if humidity <= @config.humidity.low {
      match room.state {
        case MaybeHumid -> room.update(RoomState.Closed)
        case Humid -> {
          # This ensures we ventilate for at least X minutes, then for an
          # additional Y minutes after going below the low threshold. This
          # approach is taken based on an observation of my own bathroom: when
          # starting a shower the humidity increases, then drops when the
          # ventilation is increased, after which it gradually climbs back up.
          # This drop and the climb back up to around 70-75% humidity takes
          # 15-20 minutes.
          #
          # The minimum time requirement ensures we don't stop ventilation
          # during that gap, while the low time ensures we don't keep
          # ventilating too long after reaching the low threshold, but also
          # don't stop right away as that may lead to humidity increasing again.
          if room.humid_at.elapsed >= @config.humidity.min_time
            and room.stale?(@config.humidity.low_time)
          {
            logger.info("The humidity in {room.config.name} OK again")
            room.update(RoomState.Open)
          }
        }
        case _ -> {}
      }
    }

    match room.state {
      case Humid or MaybeHumid -> true
      case _ -> false
    }
  }

  fn mut check_motion(sensors: ref Sensors, room: mut Room, time: ref DateTime) {
    let conf = match room.config.motion {
      case Some(conf) -> conf
      case _ -> return
    }

    if sensors.motion[conf.id] {
      room.motion_events = room.motion_events.wrapping_add(1)

      @metrics.send(Metric.with('motion') fn (m) {
        m.tag('room', room.config.name)
        m.field('total', room.motion_events)
      })

      match room.state {
        case Closed or Minimum -> {
          logger.info("Motion detected in {room.config.name}")

          let new_state = if conf.minutes == 1 {
            RoomState.Open
          } else {
            RoomState.Motion(time.minute, 1)
          }

          room.update(new_state)
        }
        case Motion(min, count) if min != time.minute -> {
          let new_count = count + 1
          let new_state = if new_count == conf.minutes {
            logger.info("Enabling ventilation for {room.config.name}")
            RoomState.Open
          } else {
            logger.info("More motion detected for {room.config.name}")
            RoomState.Motion(time.minute, new_count)
          }

          room.update(new_state)
        }
        case Open -> room.update_time
        case Default -> {
          logger.info(
            "Motion detected in {room.config.name} while default ventilation \
              is applied, enabling regular ventilation"
          )

          room.update(RoomState.Open)
        }
        case _ -> {}
      }

      return
    }

    match room.state {
      case Open if room.stale?(room.config.ventilation_time) -> {
        # Pinging takes a few seconds depening on the number of IPs to ping, so
        # we only do this if the timer is about to expire.
        let reset = room.config.ping.iter.any? fn (ip) { online?(ip) }

        if reset {
          logger.info(
            "One or more hosts are online, resetting timer for \
            {room.config.name}"
          )
          room.update_time
        } else {
          logger.info("Disabling ventilation for {room.config.name}")
          room.update(RoomState.Closed)
        }
      }
      case Motion(_, _) if room.stale?(conf.time) -> {
        logger.info("Not enough motion detected in {room.config.name}")
        room.update(RoomState.Closed)
      }
      case _ -> {}
    }
  }

  fn mut schedule_initial_co2_sampling {
    @rooms.iter_mut.select fn (e) { e.value.config.co2 }.each fn (entry) {
      let room = entry.value

      @logger.info("Scheduling {room.config.name} for initial CO2 sampling")
      room.update(RoomState.ScheduleCo2)
      @co2_scheduled_rooms.push(room)
    }
  }

  fn mut update_co2(status: ref Status) {
    # We postpone sampling in these cases as doing so could mess up ventilation
    # (e.g. by reducing the speed of the bathroom or kitchen extractor fan).
    if @remote.active? or @state.humid? { return }

    let sampling = @rooms.iter_mut.any? fn (entry) {
      let room = entry.value

      match room.state {
        case Co2(old_state) -> {
          let elapsed = room.last_update.elapsed
          let total_time =
            @config.co2.sample_wait_time + @config.co2.sample_time

          if elapsed > @config.co2.sample_wait_time { room.co2.add(status.co2) }

          if elapsed <= total_time {
            true
          } else {
            room.co2.update
            room.update(old_state.clone)
            logger.info(
              "Updated CO2 levels for {room.config.name} to {room.co2.value} ppm"
            )

            # We update the time here so we don't start to immediately sample
            # again after sampling the last room.
            @last_co2_update = Instant.new
            false
          }
        }
        case _ -> false
      }
    }

    if sampling { return }

    loop {
      let room = match @co2_scheduled_rooms.pop {
        case Some(room) -> room
        case _ -> break
      }

      # We have to check again as the room's state might've changed since it was
      # scheduled.
      if room.sample_co2?(@config.co2.target) {
        logger.info("Sampling CO2 {room.config.name}, state was {room.state}")
        @state = State.Co2

        let old_state = match room.state {
          case ScheduleCo2 -> RoomState.Closed
          case state -> state.clone
        }

        # For rooms using motion sensors this effectively resets the motion
        # timeout. In practise this shouldn't pose much of a problem though,
        # because in the worst case we just ventilate a room for a little longer
        # than we're supposed to.
        room.update(RoomState.Co2(old_state))
        return
      } else {
        logger.info("Not sampling {room.config.name} as ventilation stopped")
      }
    }

    if @state.co2? {
      logger.info('Finished sampling all rooms, resetting the controller state')
      @state = State.Default
    }

    if @last_co2_update.elapsed < @config.co2.sample_interval { return }

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      if room.sample_co2?(@config.co2.target) {
        logger.info("Scheduling {room.config.name} for CO2 sampling")
        @co2_scheduled_rooms.push(room)
      }
    }
  }

  fn mut send_co2_metrics(status: ref Status) {
    if @last_co2_metrics.elapsed <= @config.co2.metrics_interval { return }

    @metrics.send(Metric.with('co2') fn (m) { m.field('ppm', status.co2) })

    @rooms.values.select fn (r) { r.config.co2 }.each fn (room) {
      @metrics.send(Metric.with('co2_room') fn (m) {
        m.tag('room', room.config.name)
        m.field('ppm', room.co2.value)
      })
    }

    @last_co2_metrics = Instant.new
  }

  fn mut check_remotes {
    let conf = match @config.remote { case Some(val) -> val case _ -> return }
    let remotes = try! @itho.remotes
    let remote =
      match remotes.remove(conf.id) { case Some(val) -> val case _ -> return }

    # When starting up we ignore the current button state. This way if you
    # restart say six hours after pressing the Cook30 button, we don't start
    # ventilating according to that button again.
    if @remote.timestamp == 0 {
      @remote.timestamp = remote.timestamp
      return
    }

    if remote.timestamp == @remote.timestamp {
      let reset = match @remote.status {
        case Low -> false
        case _ -> @remote.deadline.remaining.to_nanos <= 0
      }

      if reset {
        logger.info("The {@remote.status} timer expired")
        @rooms.iter_mut.each fn (kv) { kv.value.reset_button }
        @remote.status = RemoteStatus.Low
      }

      return
    }

    @remote.status = remote.status.clone
    @remote.timestamp = remote.timestamp

    match @remote.status {
      case Low -> {
        logger.info("Resetting the remote to its default state")
        @rooms.iter_mut.each fn (entry) { entry.value.reset_button }
        return
      }
      case state -> match conf.buttons.get(state.name) {
        case Some(button) -> {
          @rooms.iter_mut.each fn (entry) { entry.value.reset_button }
          logger.info("Ventilating rooms for the {@remote.status} button")
          @remote.deadline = button.time.to_instant
          button.rooms.iter.each fn (name) {
            let room = @rooms[name]

            room.update(RoomState.Button(room.state.clone))
          }
        }
        case _ -> {}
      }
    }
  }

  fn mut update_rooms(status: ref Status, sensors: ref Sensors) {
    let time = @clock.now

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      # If the schedule is active, it takes priority over the remaining inputs.
      if check_schedule(room, time) { return }

      # If the room is humid we ignore any other sensor inputs.
      if check_humidity(status, room) { return }

      check_motion(sensors, room, time)
    }

    if @rooms.values.any?(fn (r) { r.state.humid? }).false? {
      if @state.humid? {
        logger.info('No humid rooms left, resetting the controller state')
        @state = State.Default
      }

      return
    } else if @state.humid? {
      return
    }

    # We don't allow sampling while there are humid rooms, as sampling could
    # prevent ventilating such rooms. Even if we did allow it, it would distort
    # the statistics such that sampling is useless.
    if @state.co2? { stop_co2_sampling }

    logger.info('Setting the controller state to Humid')
    @state = State.Humid
  }

  fn mut stop_co2_sampling {
    logger.info('Stopping CO2 sampling as one or more rooms are humid')

    @rooms.iter_mut.each fn (entry) {
      let room = entry.value

      match room.state {
        case Co2(old) -> room.update(old.clone)
        case _ -> {}
      }
    }

    @co2_scheduled_rooms.clear
    @last_co2_update = Instant.new
  }

  fn mut ventilate_default_room {
    # No ventilation can result in stale/dirty air building up. As such, if we
    # don't detect the need for ventilating anywhere we'll just ventilate the
    # first room.
    let ventilate_first = @rooms.iter.all? fn (entry) {
      match entry.value.state {
        case Open or Humid or Schedule or Button(_) or Co2(_) -> false
        case _ -> true
      }
    }

    let room = @rooms[@rooms.keys.next.unwrap]

    if ventilate_first {
      match room.state {
        case Default -> room.update_time
        case _ -> {
          logger.info("Enabling default ventilation for {room.config.name}")
          room.update(RoomState.Default)
        }
      }
    } else {
      match room.state {
        case Default -> {
          logger.info("Disabling default ventilation for {room.config.name}")
          room.update(RoomState.Closed)
        }
        case _ -> {}
      }
    }
  }

  fn air_flow_per_room -> Array[Int] {
    @rooms
      .values
      .map fn (room) {
        let base = match room.state {
          case Co2(_) -> {
            room.calculate_co2_flow(@config.co2.target, @config.co2.increase)
          }
          case Button(_) -> room.config.flow
          case Schedule or Open or Default -> match @state {
            # The only way we can get accurate per-room CO2 readings is to
            # temporarily disable ventilation of rooms we're not sampling.
            case Co2 -> 0

            # Humid rooms are typically ventilated at a high speed (e.g. 150
            # m3/h). Depending on how many other rooms are also ventilated, this
            # may result in a lot of noise, and potentially a lack of capacity
            # for the humid room. To handle this we temporarily reduce the
            # ventilation capacity of non-humid rooms.
            case Humid -> room.config.flow / 2

            case Default -> {
              room.calculate_flow(@config.co2.target, @config.co2.increase)
            }
          }
          case Motion(_, _) if room.config.minimum_flow > 0 -> {
            room.config.minimum_flow
          }
          case Humid -> @config.humidity.flow
          case _ -> if @state.co2? { 0 } else { room.config.minimum_flow }
        }

        (base.to_float * room.config.flow_correction).ceil.to_int
      }
      .to_array
  }

  fn mut apply_changes {
    let room_flows = air_flow_per_room
    let total_flow = max(
      @config.exhaust.min_flow,
      min(
        room_flows.iter.reduce(0, fn (sum, val) { sum + val }),
        @config.exhaust.max_flow
      )
    )

    let new_speed = flow_percentage(total_flow)

    # Speed reductions are applied first, while increases are applied last. This
    # ensures we don't produce excessive air noise while the exhaust valves are
    # adjusted.
    if new_speed < @exhaust_speed { update_exhaust_speed(new_speed) }

    @rooms.iter_mut.each_with_index fn (index, entry) {
      let room = entry.value
      let flow = room_flows[index]
      let exhaust = if flow >= total_flow {
        EXHAUST_MAX.to_int
      } else {
        (flow.to_float / total_flow.to_float * EXHAUST_MAX).ceil.to_int
      }

      @metrics.send(Metric.with('air_flow') fn (m) {
        m.tag('room', room.config.name)
        m.field('rate', flow)
        m.field('setting', exhaust)
      })

      if exhaust == room.exhaust { return }

      logger.info(
        "Changing exhaust setting for {room.config.name} from \
        {room.exhaust} to {exhaust} ({flow} m3/h)"
      )
      room.exhaust = exhaust

      try! @itho.set(setting: room.config.exhaust, value: exhaust)
      sleep(@config.exhaust.close_time)
    }

    if new_speed > @exhaust_speed { update_exhaust_speed(new_speed) }

    @metrics.send(
      Metric.with('exhaust_speed') fn (m) { m.field('percentage', new_speed) }
    )
  }

  fn mut update_exhaust_speed(new_speed: Int) {
    if new_speed < @exhaust_speed
      and @last_exhaust_update.elapsed < @config.exhaust.reduce_wait_time
    {
      return
    }

    logger
      .info("Changing exhaust speed from {@exhaust_speed}% to {new_speed}%")

    try! @itho.set(setting: @config.exhaust.speed_setting, value: new_speed)
    sleep(@config.exhaust.close_time)
    @exhaust_speed = new_speed
    @last_exhaust_update = Instant.new
  }

  fn flow_percentage(flow: Int) -> Int {
    (flow.to_float / @config.exhaust.max_flow.to_float * 100.0).ceil.to_int
  }
}
