import std::fs::file::ReadOnlyFile
import std::fs::path::IntoPath
import std::json::(self, Json)
import std::net::ip::IpAddress
import std::time::(DateTime, Duration)

fn array(object: mut Map[String, Json], key: String) !! String -> Array[Json] {
  match object.remove(key) {
    case Some(Array(v)) -> v
    case _ -> throw "The '{key}' value must be an array"
  }
}

fn int(object: mut Map[String, Json], key: String) !! String -> Int {
  match object.remove(key) {
    case Some(Int(v)) -> v
    case _ -> throw "The '{key}' value must be an integer"
  }
}

fn string(object: mut Map[String, Json], key: String) !! String -> String {
  match object.remove(key) {
    case Some(String(v)) -> v
    case _ -> throw "The '{key}' value must be a string"
  }
}

fn ip(object: mut Map[String, Json], key: String) !! String -> uni IpAddress {
  match object.remove(key) {
    case Some(String(v)) -> recover match IpAddress.parse(v) {
      case Some(addr) -> return addr
      case _ -> {}
    }
    case _ -> {}
  }

  throw "The '{key}' value must be a valid IP address"
}

# Configuration details for a fixed ventilation schedule.
class pub enum Schedule {
  # Ventilation should be enabled between 23:00 and 11:00.
  #
  # This schedule is meant for bedrooms that are used at night, as these pretty
  # much always need ventilation when in use.
  case Night

  # Ventilation should be enabled between 06:00 and 07:00.
  #
  # This schedule is meant for rooms that may build up stale/smelly air over
  # night.
  case Morning

  # Returns `true` if the schedule is/should be active.
  fn pub active?(time: ref DateTime) -> Bool {
    match self {
      case Night -> time.hour == 23 or time.hour < 11
      case Morning -> time.hour == 6
    }
  }
}

# An indicator of how the button was pressed.
class pub enum ButtonPress {
  case Short
  case Long
}

# Configuration details for a button.
class pub Button {
  # The ID of the sensor/button.
  let pub @id: Int

  # What to respond to: a short or long press.
  let pub @press: ButtonPress

  # How long the room should be ventilated for.
  let pub @time: Duration

  fn pub static from_json(value: Map[String, Json]) !! String -> Button {
    let press = match value.remove('press') {
      case Some(String('short')) -> ButtonPress.Short,
      case Some(String('long')) -> ButtonPress.Long,
      case _ -> throw 'The "press" field must be either "short" or "long"'
    }

    Button {
      @id = try int(value, 'id'),
      @press = press,
      @time = Duration.from_secs(try int(value, 'time'))
    }
  }
}

# Configuration details for a motion sensor.
class pub Motion {
  # The ID of the motion sensor attached to this room.
  let pub @id: Int

  # The amount of minutes in which motion needs to be detected before
  # ventilating the room.
  let pub @minutes: Int

  # The amount of time to wait for motion to be detected.
  let pub @time: Duration

  fn pub static from_json(value: Map[String, Json]) !! String -> Motion {
    Motion {
      @id = try int(value, 'id'),
      @minutes = try int(value, 'minutes') else 5,
      @time = Duration.from_secs(try int(value, 'time') else 900),
    }
  }
}

# Configuration details of a single room, such as the name and the motion
# sensor.
class pub Room {
  # The human-friendly name of the room.
  let pub @name: String

  # The setting index used to control the exhaust in a room.
  let pub @exhaust: Int

  # A ventilation schedule to apply.
  let pub @schedule: Option[Schedule]

  # The motion sensor for this room along with its settings.
  let pub @motion: Option[Motion]

  # The button settings for this room.
  let pub @button: Option[Button]

  # The ID of the temperature sensor attached to this room.
  let pub @temperature: Option[Int]

  # The name of the Itho humidity sensor attached to this room.
  let pub @humidity: Option[String]

  # Any IPs to ping to determine if a room should be ventilated.
  let pub @ping: Array[IpAddress]

  # The desired flow rate in h3/hour.
  let pub @flow: Int

  fn pub static from_json(value: Map[String, Json]) !! String -> Room {
    let name = try string(value, 'name')
    let exhaust = try int(value, 'exhaust')
    let schedule = match value.remove('schedule') {
      case Some(String('night')) -> Option.Some(Schedule.Night)
      case Some(String('morning')) -> Option.Some(Schedule.Morning)
      case _ -> Option.None
    }

    let motion = match value.remove('motion') {
      case Some(Object(val)) -> Option.Some(try Motion.from_json(val))
      case _ -> Option.None
    }

    let temperature = match value.remove('temperature') {
      case Some(Int(val)) -> Option.Some(val)
      case _ -> Option.None
    }

    let humidity = match value.remove('humidity') {
      case Some(String(val)) -> Option.Some(val)
      case _ -> Option.None
    }

    let flow = match value.remove('flow') {
      case Some(Int(val)) -> val
      case _ -> 15
    }

    let ping = match value.remove('ping') {
      case Some(Array(vals)) -> {
        vals
          .into_iter
          .select_map fn (val) {
            match val {
              case String(val) -> IpAddress.parse(val)
              case _ -> Option.None
            }
          }
          .to_array
      }
      case _ -> []
    }

    let button = match value.remove('button') {
      case Some(Object(val)) -> Option.Some(try Button.from_json(val))
      case _ -> Option.None
    }

    Room {
      @name = name,
      @schedule = schedule,
      @exhaust = exhaust,
      @motion = motion,
      @temperature = temperature,
      @button = button,
      @humidity = humidity
      @ping = ping,
      @flow = flow,
    }
  }
}

# Configuration details for the humidity sensors.
class pub Humidity {
  # The high threshold.
  #
  # When humidity levels exceed this value, the room is deemed too humid.
  let pub @high: Int

  # The low threshold.
  #
  # When the humidity levels are reduced to or below this level, the room is
  # considered dry enough.
  let pub @low: Int

  # The amount of time to wait after the high threshold is exceeded, before
  # ventilating a room.
  let pub @high_time: Duration

  # The amount of time to wait after the low threshold is reached, before
  # turning ventilation back to normal.
  let pub @low_time: Duration

  # The air flow rate in m3/hour to apply to a room when it's too humid.
  let pub @flow: Int

  fn pub static from_json(value: Map[String, Json]) !! String -> Humidity {
    let high = try int(value, 'high')
    let low = try int(value, 'low')
    let low_time = Duration.from_secs(try int(value, 'low_time'))
    let high_time = Duration.from_secs(try int(value, 'high_time'))
    let flow = try int(value, 'flow')

    Humidity {
      @high = high,
      @low = low,
      @low_time = low_time,
      @high_time = high_time,
      @flow = flow,
    }
  }
}

# Configuration details for the exhaust fan and valves.
class pub Exhaust {
  # The minimum flow of air in m3/hour.
  let pub @min_flow: Int

  # The maximum supported flow of air in m3/hour.
  let pub @max_flow: Int

  # The amount of time to wait for an exhaust valve to close.
  let pub @close_time: Duration

  # The amount of time to wait after an exhaust speed change before we allow
  # reducing the speed again.
  let pub @reduce_wait_time: Duration

  # The setting that controls the speed.
  let pub @speed_setting: Int

  # The setting that enables/disables manual control.
  let pub @manual_setting: Int

  fn pub static from_json(value: Map[String, Json]) !! String -> Exhaust {
    Exhaust {
      @min_flow = try int(value, 'min_flow'),
      @max_flow = try int(value, 'max_flow'),
      @close_time = Duration.from_secs(try int(value, 'close_time')),
      @speed_setting = try int(value, 'speed_setting'),
      @manual_setting = try int(value, 'manual_setting'),
      @reduce_wait_time = Duration.from_secs(try int(value, 'reduce_wait_time')),
    }
  }
}

# Configuration settings for the CO2 levels.
class pub Co2 {
  # The target/desired CO2 concentration.
  let pub @target: Int

  # The amount of time to gather samples before calculating a new CO2 estimate.
  let pub @sample_time: Duration

  fn pub static from_json(value: Map[String, Json]) !! String -> Co2 {
    Co2 {
      @target = try int(value, 'target'),
      @sample_time = Duration.from_secs(try int(value, 'sample_time')),
    }
  }
}

# Various configuration settings, such as the settings to control the
# ventilation and the room-specific settings.
class pub Config {
  # Rooms to ventilate.
  let pub @rooms: Array[Room]

  # The IP address of the Ith WiFi add-on API.
  let pub @itho_wifi_address: uni IpAddress

  # The IP address of the Philips Hue bridge API.
  let pub @hue_address: uni IpAddress

  # The username/key for the Philips Hue API.
  let pub @hue_user: String

  # The humidity sensor settings.
  let pub @humidity: Humidity

  # The settings to control the exhaust fan and valves.
  let pub @exhaust: Exhaust

  # The amount of time (in seconds) to keep ventilating a room after the last
  # motion event.
  let pub @ventilation_time: Duration

  # Configuration settings related to the CO2 levels.
  let pub @co2: Co2

  fn pub static load(path: IntoPath) !! String -> Config {
    let file = try {
      ReadOnlyFile.new(path)
    } else (err) {
      throw "Failed to load the configuration file: {err}"
    }

    let bytes = ByteArray.new

    try file.read_all(bytes) else (e) throw e.to_string

    let doc = try {
      json.parse(bytes.into_string)
    } else (err) {
      throw "Failed to parse the configuration file: {err}"
    }

    let root = match doc {
      case Object(v) -> v
      case _ -> throw 'The top-level JSON value must be an object'
    }

    let rooms = []
    let rooms_iter = try { array(root, 'rooms') }.into_iter

    loop {
      match rooms_iter.next {
        case Some(Object(map)) -> rooms.push(try Room.from_json(map))
        case Some(_) -> throw "The 'rooms' setting can only contain objects"
        case None -> break
      }
    }

    let humidity = match root.remove('humidity') {
      case Some(Object(map)) -> try Humidity.from_json(map),
      case _ -> throw 'The "humidity" object is required'
    }

    let exhaust = match root.remove('exhaust') {
      case Some(Object(map)) -> try Exhaust.from_json(map)
      case _ -> throw 'The "exhaust" object is required'
    }

    let co2 = match root.remove('co2') {
      case Some(Object(map)) -> try Co2.from_json(map)
      case _ -> throw 'The "co2" object is required'
    }

    let ventilation_time =
      Duration.from_secs(try int(root, 'ventilation_time'))

    Config {
      @rooms = rooms,
      @itho_wifi_address = try ip(root, 'itho_api'),
      @hue_address = try ip(root, 'hue_api'),
      @hue_user = try string(root, 'hue_user'),
      @humidity = humidity,
      @exhaust = exhaust,
      @ventilation_time = ventilation_time,
      @co2 = co2,
    }
  }
}
