import openflow::config::(Room as Config)
import std::clone::Clone
import std::cmp::Equal
import std::fmt::(Format, Formatter)
import std::time::(DateTime, Duration, Instant)

# The state of a ventilation exhaust.
class pub enum State {
  # The exhaust is closed.
  case Closed

  # The room is ventilated according to a fixed schedule.
  case Schedule

  # Humidity in the room is increasing, but it's not yet high enough to switch
  # to the "Humid" state.
  case MaybeHumid

  # The exhaust is fully opened to ventilate a humid room, and shouldn't be
  # changed by the input of any sensors.
  case Humid

  # The room is ventilated using its minimum flow rate.
  case Minimum

  # Regular ventilation is or should be applied to the room.
  case Open

  # The room is ventilated because no other rooms need ventilation.
  case Default

  # The room is ventilated in response to an RF remote button.
  #
  # The wrapped value is the state to revert to when the timer expires.
  case Button(State)

  # A motion sensor detected movement, and we may need to ventilate the room if
  # motion continues.
  #
  # The first value is the last minute motion was detected at. The second value
  # is the total number of minutes in which motion is detected.
  case Motion(Int, Int)

  fn pub schedule? -> Bool {
    match self {
      case Schedule -> true
      case _ -> false
    }
  }
}

impl Equal for State {
  fn pub ==(other: ref Self) -> Bool {
    match (self, other) {
      case (Closed, Closed) -> true
      case (Schedule, Schedule) -> true
      case (MaybeHumid, MaybeHumid) -> true
      case (Humid, Humid) -> true
      case (Open, Open) -> true,
      case (Minimum, Minimum) -> true
      case (Default, Default) -> true
      case (Motion(l1, l2), Motion(r1, r2)) -> l1 == r1 and l2 == r2
      case (Button(a), Button(b)) -> a == b
      case _ -> false
    }
  }
}

impl Format for State {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Closed -> formatter.write('Closed')
      case Schedule -> formatter.write('Schedule')
      case MaybeHumid -> formatter.write('MaybeHumid')
      case Humid -> formatter.write('Humid')
      case Open -> formatter.write('Open')
      case Minimum -> formatter.write('Minimum')
      case Default -> formatter.write('Default')
      case Motion(a, b) -> formatter.write("Motion({a}, {b})")
      case Button(state) -> {
        formatter.write('Button(')
        state.fmt(formatter)
        formatter.write(')')
      }
    }
  }
}

impl Clone for State {
  fn pub clone -> State {
    match self {
      case Closed -> State.Closed
      case Schedule -> State.Schedule
      case MaybeHumid -> State.MaybeHumid
      case Humid -> State.Humid
      case Open -> State.Open
      case Minimum -> State.Minimum
      case Default -> State.Default
      case Motion(a, b) -> State.Motion(a, b)
      case Button(old) -> State.Button(old.clone)
    }
  }
}

# The state of a room to ventilate.
class pub Room {
  # The configuration settings for this room.
  let pub @config: ref Config

  # The current state of the exhaust.
  let pub @state: State

  # The last time the state of this room was updated.
  let pub @last_update: Instant

  # The timestamp at which the room was marked as humid
  #
  # This value is only relevant if the state is `Humid`, otherwise it may be an
  # outdated value.
  let pub @humid_at: Instant

  # The total number of motion events detected.
  let pub @motion_events: Int

  # How far the exhaust is opened.
  #
  # This is tracked separate from the state as the value is not yet known when
  # first changing a room from "closed" to "open".
  let pub @exhaust: Int

  fn pub static new(config: ref Config) -> Room {
    let now = Instant.new
    let state =
      if config.minimum_flow > 0 { State.Minimum } else { State.Closed }

    Room {
      @config = config,
      @state = state,
      @last_update = now.clone,
      @exhaust = 0,
      @humid_at = now,
      @motion_events = 0,
    }
  }

  fn pub mut update_time {
    @last_update = Instant.new
  }

  fn pub stale?(duration: ref Duration) -> Bool {
    @last_update.elapsed >= duration
  }

  fn pub mut update(state: State) {
    @state = state

    match @state {
      # Additional pending states shouldn't change the update timestamp,
      # otherwise we'd reset the time window upon every movement.
      case Motion(_, count) if count > 1 -> {}
      case _ -> @last_update = Instant.new
    }
  }

  fn pub mut close {
    let new_state =
      if @config.minimum_flow > 0 { State.Minimum } else { State.Closed }

    update(new_state)
  }

  fn pub mut reset_button {
    match @state { case Button(old) -> update(old.clone), case _ -> {} }
  }
}
