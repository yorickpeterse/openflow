import openflow::co2::(SIZE, Co2 as Co2)
import openflow::experimental_ext
import openflow::logger::Logger
import openflow::metrics::(Metric, Metrics)
import openflow::more_sense::MoreSense
import openflow::state::(State, Status)
import std::cmp::(max)
import std::process::(sleep)
import std::time::(Duration, Instant)

# The target CO2 level.
#
# We're targeting this level as higher values can lead to a sleepy and stuffy
# feeling.
let TARGET = 800

# The CO2 value at which active ventilation is enabled.
let LOWER = TARGET - 200

# The CO2 value at which active ventilation needs to be increased more than
# usual.
let MID = TARGET - 100

# The CO2 value at which to activate maximum ventilation.
let UPPER = TARGET + 100

# The minimum speed in m3/h to apply in response to CO2 levels.
let MIN_SPEED = 20

# The speed increase in m3/h per CO2 bucket.
let SPEED_PER_BUCKET = 10

# The extra speed to add per bucket when CO2 levels are getting closer to the
# target value.
let EXTRA_PER_BUCKET = 5

# How many samples we should gather before updating the CO2 levels.
let pub SAMPLES = 20

# The minimum CO2 reduction desired before lowering the ventilation speed.
#
# Reductions of e.g. 50 ppm aren't significant enough to warrant reducing
# ventilation speeds, so we maintain the speed (even after reaching the
# ventilation timeout) until we've reduced the CO2 levels enough.
#
# This in turn prevents us from reducing the speed due to a brief reduction in
# CO2 levels after the timeout, only to increase the speed again a few moments
# later.
let MIN_CO2_REDUCTION = 100

# The state of a single CO2 sensor.
class pub Sensor {
  let @name: String
  let @client: MoreSense
  let @co2: Co2

  # The ventilation status of the room this sensor belongs to.
  let @status: Status

  # The time at which the current status was produced.
  let @last_status_change: Instant

  # The CO2 at the time of the last status change.
  let @last_change_co2: Int

  fn pub static new(name: String, client: MoreSense) -> Sensor {
    Sensor {
      @name = name,
      @client = client,
      @co2 = Co2.new,
      @status = Status.Default,
      @last_status_change = Instant.new,
      @last_change_co2 = 0,
    }
  }

  fn mut sample -> Result[Nil, String] {
    @co2.add(try @client.co2)
    Result.Ok(nil)
  }

  fn value -> Int {
    @co2.value
  }

  fn mut update_co2 -> Int {
    @co2.update
    @co2.value
  }

  fn mut update_status(status: Status) {
    @status = status
    @last_status_change = Instant.new
    @last_change_co2 = @co2.value
  }

  fn reduce?(after: ref Duration) -> Bool {
    if @last_status_change.elapsed < after { return false }
    if @last_change_co2 <= LOWER { return true }

    @last_change_co2 - @co2.value >= MIN_CO2_REDUCTION
  }
}

# A process monitoring a set of CO2 sensors, adjusting ventilation based on the
# CO2 levels.
class pub async Input {
  let @state: State
  let @logger: Logger
  let @metrics: Metrics

  # The room names and their corresponding sensors to monitor.
  let @sensors: Array[Sensor]

  # The time between CO2 samples.
  let @sample_interval: Duration

  # The amount of time to wait after an update before reducing the ventilation
  # speed of a room.
  let @reduce_wait_time: Duration

  fn pub static new(
    state: State,
    logger: Logger,
    metrics: uni Metrics,
  ) -> Input {
    Input {
      @state = state,
      @logger = logger,
      @metrics = metrics,
      @sensors = recover [],
      @sample_interval = recover Duration.from_secs(30),
      @reduce_wait_time = recover Duration.from_secs(1800),
    }
  }

  fn pub async mut add_sensor(sensor: uni Sensor) {
    @sensors.push(sensor)
  }

  fn pub async mut run {
    loop { iteration }
  }

  fn mut iteration {
    SAMPLES.times fn (_) {
      sleep(@sample_interval)
      sample
    }

    update
  }

  fn mut update {
    let updates = @sensors.iter_mut.reduce(recover Map.new) fn (map, sensor) {
      let old = sensor.value
      let new = sensor.update_co2
      let status = recover {
        if new >= UPPER {
          Status.Maximum
        } else if new >= LOWER {
          # When CO2 levels are getting close to the target value, we start
          # increasing the speed a bit more than usual, in an attempt to prevent
          # CO2 from reaching the target value.
          let mut speed = MIN_SPEED
            + (new - LOWER / SIZE * SPEED_PER_BUCKET)
            + max(0, new - MID / SIZE * EXTRA_PER_BUCKET)

          Status.Active(speed)
        } else {
          Status.Default
        }
      }

      if status >= sensor.status or sensor.reduce?(@reduce_wait_time) {
        sensor.update_status(status.clone)
        map.set(sensor.name, status)
      }

      @metrics.add('co2_room') fn (m) {
        m.tag('room', sensor.name)
        m.field('ppm', new)
      }

      map
    }

    apply(updates)
  }

  fn mut sample {
    @sensors.iter_mut.each fn (sensor) {
      match sensor.sample {
        case Ok(_) -> {}
        case Error(e) -> error(sensor.name, "failed to read the CO2 value: {e}")
      }
    }
  }

  fn apply(updates: uni Map[String, Status]) {
    @state.update_with(updates) fn move (rooms, updates) {
      updates.into_iter.each fn (entry) {
        entry.let fn (name, status) {
          let room = rooms.get_mut(name)

          match room.status {
            case Humid or Button(_) -> {}
            case _ -> room.update(status)
          }
        }
      }

      false
    }
  }

  fn mut error(room: String, message: String) {
    @logger.error("{room}: {message}")
  }
}
