import openflow::clock::(Clock, TestClock)
import openflow::config::(
  Button, ButtonPress, Co2, Config, Exhaust, Humidity, Motion, Room, Schedule
)
import openflow::controller::Controller
import openflow::http::(Client, Request, Response, TestDriver)
import openflow::hue::Hue
import openflow::itho::Itho
import openflow::logger::Logger
import openflow::room::State
import std::io::Write
import std::json::Json
import std::net::ip::IpAddress
import std::test::Tests
import std::time::(DateTime, Duration, Instant)

class CycleClock {
  let @index: Int

  fn static new -> CycleClock {
    CycleClock { @index = 0 }
  }
}

impl Clock for CycleClock {
  fn pub mut now -> DateTime {
    let hour = if @index == 0 {
      @index = 1
      23
    } else {
      @index = 0
      14
    }

    DateTime {
      @year = 2023,
      @month = 1,
      @day = 12,
      @hour = hour,
      @minute = 4,
      @second = 2,
      @sub_second = 0.0,
      @utc_offset = 0,
    }
  }
}

let SPEED = 124

class NullWriter {}

impl Write for NullWriter {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Int {
    0
  }

  fn pub mut write_string(string: String) -> Int {
    0
  }

  fn pub mut flush {}
}

fn config -> Config {
  Config {
    @rooms = [
      Room {
        @name = 'Living room',
        @exhaust = 12,
        @schedule = Option.None,
        @motion = Option.Some(Motion {
          @id = 1,
          @minutes = 5,
          @time = Duration.from_secs(10),
        }),
        @button = Option.None,
        @temperature = Option.None,
        @humidity = Option.None,
        @ping = [],
        @flow = 15,
      },
      Room {
        @name = 'Bedroom',
        @exhaust = 13,
        @schedule = Option.Some(Schedule.Night),
        @motion = Option.None,
        @button = Option.None,
        @temperature = Option.None,
        @humidity = Option.None,
        @ping = [],
        @flow = 60,
      },
      Room {
        @name = 'Bathroom',
        @exhaust = 14,
        @schedule = Option.None,
        @motion = Option.Some(Motion {
          @id = 2,
          @minutes = 5,
          @time = Duration.from_secs(10),
        }),
        @button = Option.None,
        @temperature = Option.None,
        @humidity = Option.Some('RH foo'),
        @ping = [],
        @flow = 50,
      },
      Room {
        @name = 'Office',
        @exhaust = 15,
        @schedule = Option.None,
        @motion = Option.Some(Motion {
          @id = 3,
          @minutes = 5,
          @time = Duration.from_secs(10),
        }),
        @button = Option.Some(Button {
          @id = 4,
          @press = ButtonPress.Short,
          @time = Duration.from_secs(10),
        }),
        @temperature = Option.None,
        @humidity = Option.None,
        @ping = [],
        @flow = 15,
      },
    ],
    @humidity = Humidity {
      @high = 75,
      @low = 70,
      @low_time = Duration.from_secs(1),
      @high_time = Duration.from_secs(1),
      @flow = 150,
    },
    @exhaust = Exhaust {
      @manual_setting = 111,
      @speed_setting = SPEED,
      @min_flow = 90,
      @max_flow = 350,
      @close_time = Duration.from_secs(0),
      @reduce_wait_time = Duration.from_secs(60),
    },
    @itho_wifi_address = recover IpAddress.v4(192, 0, 0, 1),
    @hue_address = recover IpAddress.v4(192, 0, 0, 2),
    @hue_user = 'foo',
    @co2 = Co2 {
      @target = 700,
      @sample_time = Duration.from_secs(900),
    },
    @ventilation_time = Duration.from_secs(10),
  }
}

fn controller(
  config: Config,
  itho_driver: TestDriver,
  hue_driver: TestDriver,
  clock: Clock,
) -> Controller {
  let itho = Itho.new(Client.with_driver(itho_driver))
  let hue = Hue.new(Client.with_driver(hue_driver), user: 'foo')
  let logger = Logger.new(NullWriter {})

  Controller.new(config, itho, hue, clock, logger)
}

fn itho(co2: Int, humidity: Int) -> TestDriver {
  let driver = TestDriver.new

  driver.request(
    matches: fn (req) {
      match req.queries.get('get') {
        case Some('ithostatus') -> true
        case _ -> false
      }
    },
    then: fn (_) {
      Response.ok(
        "\{ \"CO2 plenum (ppm)\": {co2}, \"RH foo\": {humidity} }".to_byte_array
      )
    }
  )

  driver
}

fn track_settings(driver: mut TestDriver) -> Array[(Int, Int)] {
  let updates = []

  driver.request(
    matches: fn (req) { req.queries.get('setsetting').some? },
    then: fn (req) {
      updates.push(
        (
          Int.from_base10(req.queries['setsetting']).unwrap_or(0),
          Int.from_base10(req.queries['value']).unwrap_or(0),
        )
      )
      Response.ok('OK'.to_byte_array)
    }
  )

  updates
}

fn hue -> TestDriver {
  let driver = TestDriver.new

  driver.request(
    matches: fn (req) { req.path == '/api/foo/sensors' },
    then: fn (_) {
      Response.ok(
        '
        {
          "1": { "type": "ZLLPresence", "state": { "presence": false } },
          "2": { "type": "ZLLPresence", "state": { "presence": false } },
          "3": { "type": "ZLLPresence", "state": { "presence": true } },
          "4": {
            "type": "ZLLSwitch",
            "state": {
              "buttonevent": 1002,
              "lastupdated": "2023-02-16T14:10:22"
            }
          }
        }
        '.to_byte_array
      )
    }
  )

  driver
}

fn hour(hour: Int) -> TestClock {
  TestClock.new(DateTime {
    @year = 2023,
    @month = 1,
    @day = 12,
    @hour = hour,
    @minute = 4,
    @second = 2,
    @sub_second = 0.0,
    @utc_offset = 0,
  })
}

fn button_time -> DateTime {
  DateTime {
    @year = 2023,
    @month = 2,
    @day = 16,
    @hour = 14,
    @minute = 10,
    @second = 15,
    @sub_second = 0.0,
    @utc_offset = 0,
  }
}

fn pub tests(t: mut Tests) {
  t.test('A room for which to enable a schedule') fn (t) {
    let itho = itho(co2: 1, humidity: 1)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(23))
    let room = ctl.rooms[1]

    ctl.iteration

    t.equal(room.state, State.Schedule)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
    t.true(updates.contains?((SPEED, 26)))
  }

  t.test('A room for which to disable a schedule') fn (t) {
    let itho = itho(co2: 700, humidity: 73)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[1]

    room.state = State.Schedule
    room.exhaust = 500
    ctl.iteration

    t.equal(room.state, State.Closed)
    t.true(updates.contains?((room.config.exhaust, 0)))
    t.true(updates.contains?((SPEED, 26)))
  }

  t.test('A room that is already running a schedule') fn (t) {
    let itho = itho(co2: 700, humidity: 73)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(23))
    let room = ctl.rooms[1]
    let before = Instant.new

    room.state = State.Schedule
    room.last_update = before.clone
    room.exhaust = 1389
    ctl.iteration

    t.equal(room.state, State.Schedule)
    t.equal(room.last_update, before)
  }

  t.test('First detecting an increase in humidity') fn (t) {
    let itho = itho(co2: 700, humidity: 80)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[2]

    ctl.iteration

    t.equal(room.state, State.MaybeHumid)
  }

  t.test('Detecting an increase in humidity a second time') fn (t) {
    let itho = itho(co2: 700, humidity: 80)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[2]

    ctl.iteration

    let update = room.last_update.clone

    ctl.iteration

    t.equal(room.state, State.MaybeHumid)
    t.equal(room.last_update, update)
  }

  t.test('A room that is becoming too humid') fn (t) {
    let conf = config

    conf.humidity.high_time = Duration.from_secs(0)

    let itho = itho(co2: 700, humidity: 80)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[2]

    room.state = State.MaybeHumid
    ctl.iteration

    t.equal(room.state, State.Humid)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
    t.true(updates.contains?((SPEED, 43)))
  }

  t.test('A room that is too humid') fn (t) {
    let itho = itho(co2: 700, humidity: 80)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[2]
    let before = Instant.new + Duration.from_secs(10)

    room.state = State.Humid
    room.last_update = before.clone
    room.exhaust = 5000
    ctl.iteration

    t.equal(room.state, State.Humid)
    t.not_equal(room.last_update, before)
  }

  t.test('A room that was humid but not for long enough') fn (t) {
    # This covers both the cases of `humidity >= low` and `humidity < low`.
    [70, 60].into_iter.each fn (humidity) {
      let itho = itho(co2: 700, humidity: humidity)
      let _ = track_settings(itho)
      let ctl = controller(config, itho, hue, hour(14))
      let room = ctl.rooms[2]

      room.state = State.MaybeHumid
      ctl.iteration

      t.equal(room.state, State.Closed)
    }
  }

  t.test('A room that has dried up') fn (t) {
    let conf = config

    conf.humidity.low_time = Duration.from_secs(0)

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[2]

    room.state = State.Humid
    room.exhaust = 5000
    ctl.iteration

    t.equal(room.state, State.Open)
    t.equal(room.exhaust, 2778)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
  }

  t.test('A room with increasing humidity') fn (t) {
    let itho = itho(co2: 700, humidity: 71)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[2]

    ctl.iteration

    t.equal(room.state, State.Open)
    t.equal(room.exhaust, 2778)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))

    let before = room.last_update

    # The second iteration observes the room to already be open, so instead the
    # timestamp is updated.
    ctl.iteration

    t.true(room.last_update > before)
  }

  t.test('A dry room when the humidity levels are OK') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[2]
    let before = Instant.new + Duration.from_secs(10)

    room.state = State.Open
    room.last_update = before.clone
    room.exhaust = 2778
    ctl.iteration

    t.equal(room.state, State.Open)
    t.equal(room.last_update, before)
  }

  t.test('A room with motion detected for the first time') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    ctl.iteration

    t.equal(room.state, State.Motion(4, 1))
  }

  t.test('A room with motion detected multiple times in the same minute') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    ctl.iteration
    ctl.iteration

    t.equal(room.state, State.Motion(4, 1))
  }

  t.test('A room with motion detected in two different minutes') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    room.state = State.Motion(3, 1)
    ctl.iteration

    t.equal(room.state, State.Motion(4, 2))
  }

  t.test('A room with enough motion events detected') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    room.state = State.Motion(3, 4)
    ctl.iteration

    t.equal(room.state, State.Open)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
  }

  t.test('A room with motion while ventilation is already active') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]
    let before = Instant.new + Duration.from_secs(10)

    room.state = State.Open
    room.last_update = before.clone
    room.exhaust = 834
    ctl.iteration

    t.equal(room.state, State.Open)
    t.not_equal(room.last_update, before)
  }

  t.test('A room that is ventilated but is now vacant') fn (t) {
    let conf = config

    conf.ventilation_time = Duration.from_secs(0)

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[2]

    room.state = State.Open
    room.exhaust = 2778
    ctl.iteration

    t.equal(room.state, State.Closed)
    t.equal(room.exhaust, 0)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
  }

  t.test('A vacant room with an IP responding to a ping') fn (t) {
    let conf = config

    conf.ventilation_time = Duration.from_secs(0)
    conf.rooms[2].ping.push(IpAddress.v4(127, 0, 0, 1))

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[2]
    let before = room.last_update.clone

    room.state = State.Open
    room.exhaust = 2778
    ctl.iteration

    t.equal(room.state, State.Open)
    t.not_equal(room.last_update, before)
    t.equal(room.exhaust, 2778)
  }

  t.test('A room with not enough motion events') fn (t) {
    let conf = config

    conf.rooms[2].motion.as_mut.unwrap.time = Duration.from_secs(0)

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[2]

    room.state = State.Motion(1, 1)
    ctl.iteration

    t.equal(room.state, State.Closed)
  }

  t.test('Ventilating the first room when no other rooms need ventilation') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[0]

    ctl.iteration

    t.equal(room.state, State.Default)
    t.equal(room.exhaust, 834)
    t.true(updates.contains?((room.config.exhaust, room.exhaust)))
  }

  t.test('The first room is not ventilated when another room needs ventilation') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let _ = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(23))

    ctl.iteration

    t.equal(ctl.rooms[0].state, State.Closed)
  }

  t.test('The first room is closed when another room needs ventilating') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let living_room = ctl.rooms[0]
    let bedroom = ctl.rooms[1]

    ctl.iteration
    t.equal(living_room.state, State.Default)

    bedroom.update(State.Open)
    ctl.iteration

    t.equal(living_room.state, State.Closed)
    t.equal(bedroom.state, State.Open)
    t.true(updates.contains?((bedroom.config.exhaust, bedroom.exhaust)))
    t.true(updates.contains?((living_room.config.exhaust, 0)))
  }

  t.test('Updating the exhaust settings') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(23))
    let room = ctl.rooms[1]

    ctl.iteration

    t.equal(updates, [(room.config.exhaust, room.exhaust), (SPEED, 26)])
  }

  t.test('Increasing the flow when CO2 levels are high') fn (t) {
    let conf = config

    conf.co2.sample_time = Duration.from_secs(0)

    let itho = itho(co2: 1200, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(23))
    let room = ctl.rooms[1]

    ctl.iteration

    t.equal(updates, [(room.config.exhaust, room.exhaust), (SPEED, 32)])
  }

  t.test('No extra flow is added when a room is humid') fn (t) {
    let conf = config

    conf.co2.sample_time = Duration.from_secs(0)
    conf.humidity.high_time = Duration.from_secs(0)

    let itho = itho(co2: 1200, humidity: 80)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(23))
    let bathroom = ctl.rooms[2]
    let bedroom = ctl.rooms[1]

    bathroom.state = State.Humid
    bathroom.exhaust = 4167
    ctl.iteration

    t.equal(updates, [(bedroom.config.exhaust, 834), (SPEED, 52)])
  }

  t.test('The exhaust speed is limited to the maximum flow') fn (t) {
    let conf = config

    conf.exhaust.min_flow = 10
    conf.exhaust.max_flow = 30

    let itho = itho(co2: 700, humidity: 60)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(23))
    let bedroom = ctl.rooms[1]

    ctl.iteration

    t.equal(updates, [(bedroom.config.exhaust, 5000), (SPEED, 100)])
  }

  t.test('The exhaust speed is always greater than the minimum flow') fn (t) {
    let conf = config

    conf.rooms[1].flow = 5

    let itho = itho(co2: 700, humidity: 60)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(23))
    let bedroom = ctl.rooms[1]

    ctl.iteration

    t.equal(updates, [(bedroom.config.exhaust, 278), (SPEED, 26)])
  }

  t.test('The exhaust is only updated when there is a speed change') fn (t) {
    let itho = itho(co2: 700, humidity: 60)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(23))
    let bedroom = ctl.rooms[1]

    ctl.iteration
    ctl.iteration

    t.equal(updates, [(bedroom.config.exhaust, 3334), (SPEED, 26)])
  }

  t.test('The exhaust speed is only reduced after a period of time') fn (t) {
    let itho = itho(co2: 700, humidity: 80)
    let updates = track_settings(itho)
    let clock = CycleClock.new
    let ctl = controller(config, itho, hue, clock)
    let bedroom = ctl.rooms[1]
    let bathroom = ctl.rooms[2]

    bathroom.state = State.Humid
    bathroom.exhaust = 5000
    ctl.iteration
    ctl.iteration

    t.equal(
      updates,
      [
        (bedroom.config.exhaust, 834),
        (bathroom.config.exhaust, 4167),
        (SPEED, 52),
        (bedroom.config.exhaust, 0),
        (bathroom.config.exhaust, 5000),
      ]
    )
  }

  t.test('Detecting motion in a room that has default ventilation applied') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    room.state = State.Default
    room.exhaust = 834
    ctl.iteration

    t.equal(room.state, State.Open)
    t.equal(room.exhaust, 834)
  }

  t.test('Enabling ventilation in response to a button press') fn (t) {
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    # The first time we ignore the button state, otherwise we can't track state
    # changes.
    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))

    room.last_button_press = Option.Some(button_time)

    # With the button state changed, the room should be ventilated.
    ctl.iteration
    t.equal(room.state, State.Button)
    t.true(updates.contains?((room.config.exhaust, 834)))
  }

  t.test("Ignoring a button that can't be found") fn (t) {
    let conf = config

    conf.rooms[3].button.as_mut.unwrap.id = 42

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[3]

    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))
  }

  t.test('Ignoring a button press of a different kind') fn (t) {
    let conf = config

    conf.rooms[3].button.as_mut.unwrap.press = ButtonPress.Long

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[3]

    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))

    room.last_button_press = Option.Some(button_time)

    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))
  }

  t.test('Button events are ignored if the time is in the past') fn (t) {
    # When the Hue Bridge is blocked from accessing the network, timestamps at
    # some point wrap around to 1980, after which they seem to continue as usual.
    # To prevent such a random wrap-around from triggering a button, we _do_
    # track the new date but _don't_ fire a button event.
    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(config, itho, hue, hour(14))
    let room = ctl.rooms[3]

    # The first time we ignore the button state, otherwise we can't track state
    # changes.
    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))

    room.last_button_press = Option.Some(DateTime {
      @year = 2023,
      @month = 2,
      @day = 16,
      @hour = 14,
      @minute = 12,
      @second = 15,
      @sub_second = 0.0,
      @utc_offset = 0,
    })

    ctl.iteration
    t.equal(room.state, State.Motion(4, 1))
  }

  t.test('Disabling ventilation from a button after the timeout expires') fn (t) {
    let conf = config

    conf.rooms[3].button.as_mut.unwrap.time = Duration.from_secs(0)

    let itho = itho(co2: 700, humidity: 65)
    let updates = track_settings(itho)
    let ctl = controller(conf, itho, hue, hour(14))
    let room = ctl.rooms[3]

    # The first iteration ignores the state.
    ctl.iteration

    # The second iteration enables the button mode.
    room.last_button_press = Option.Some(button_time)
    ctl.iteration

    t.equal(room.state, State.Button)

    # The third iteration disables the button mode, because the timeout expired.
    ctl.iteration

    t.equal(room.state, State.Motion(4, 1))
    t.true(updates.contains?((room.config.exhaust, 0)))
  }
}
